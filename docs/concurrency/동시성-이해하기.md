# 동시성 완벽 이해 가이드

## 🎯 목표
복잡한 동시성 개념을 **실생활 비유 + 그림 + 실제 코드**로 완벽 이해!

---

## 1. 동시성이란? (실생활 비유)

### 🚻 화장실 비유

```
상황: 화장실이 1개, 사람은 3명

❌ 자물쇠 없으면:
Person-1 ───────┐
Person-2 ───────┼─→ 💥 충돌! (3명이 동시에 들어감)
Person-3 ───────┘

✅ 자물쇠 있으면:
Person-1 ─────→ 🔒 사용 중 ─────→ 🔓 나옴
Person-2 ─────→ ⏳ 대기 ─────→ 🔒 사용 중 ─────→ 🔓 나옴
Person-3 ─────→ ⏳ 대기 ─────→ ⏳ 대기 ─────→ 🔒 사용 중 ─────→ 🔓 나옴
```

**동시성 제어 = 자물쇠로 순서대로 사용하게 만들기**

---

## 2. 우리 프로젝트의 문제

### 시나리오: 사용자가 실수로 주문 버튼 2번 클릭

```
시간 →

[0ms]  사용자: 클릭! (첫 번째)
       Thread-1: 주문 처리 시작

[50ms] 사용자: 또 클릭! (실수로)
       Thread-2: 주문 처리 시작

❌ 분산락 없으면:
Thread-1 │ 재고 확인: 100개 ✅
         │ 주문 생성 중...
         │
Thread-2 │ 재고 확인: 100개 ✅ (Thread-1이 아직 재고 감소 안 함!)
         │ 주문 생성 중...
         │
결과: 중복 주문 2건! 💥
```

```
✅ 분산락 있으면:
Thread-1 │ 🔒 락 획득 (order:user:1)
         │ 재고 확인: 100개 ✅
         │ 재고 감소: 100 → 90
         │ 주문 생성 완료
         │ 🔓 락 해제
         │
Thread-2 │ ⏳ 락 대기 중... (Thread-1 끝날 때까지)
         │ 🔒 락 획득
         │ 재고 확인: 90개 ✅
         │ 재고 감소: 90 → 80
         │ 주문 생성 완료
         │ 🔓 락 해제
         │
결과: 정상 처리 2건! ✅
```

---

## 3. 분산락 동작 원리 (단계별)

### Step 1: 락 획득 시도

```java
String lockKey = "order:user:1";
RLock lock = redissonClient.getLock(lockKey);

// tryLock(waitTime, leaseTime, TimeUnit)
boolean acquired = lock.tryLock(5, 10, TimeUnit.SECONDS);
```

**Redis 내부 (Lua 스크립트):**
```lua
-- 1. 락이 있는지 확인
if (redis.call('exists', 'order:user:1') == 0) then
    -- 2. 없으면 생성
    redis.call('hset', 'order:user:1', 'thread123', 1)
    -- 3. 10초 후 자동 삭제 설정
    redis.call('pexpire', 'order:user:1', 10000)
    return nil  -- 성공!
end

-- 이미 다른 스레드가 보유 중
return redis.call('pttl', 'order:user:1')  -- 남은 시간 반환
```

### Step 2: 비즈니스 로직 실행

```java
if (acquired) {
    try {
        // 주문 처리 (1~2초)
        executeInternal(command);
    } finally {
        // 반드시 해제!
        lock.unlock();
    }
}
```

### Step 3: 락 해제

```lua
-- unlock Lua 스크립트
-- 1. 내가 보유한 락인지 확인
if (redis.call('hexists', 'order:user:1', 'thread123') == 1) then
    -- 2. 삭제
    redis.call('del', 'order:user:1')
    -- 3. 대기 중인 스레드에 알림 (Pub/Sub)
    redis.call('publish', 'unlock_channel', 'unlock')
    return 1
end
```

---

## 4. 타임라인으로 보는 동시성

### 시나리오: 5개 스레드가 동시 주문

```
시간(ms) │ Thread-1  │ Thread-2  │ Thread-3  │ Thread-4  │ Thread-5
─────────┼───────────┼───────────┼───────────┼───────────┼──────────
    0    │ 🔒 락획득  │ ⏳ 대기    │ ⏳ 대기    │ ⏳ 대기    │ ⏳ 대기
  500    │ 💳 주문중  │ ⏳ 대기    │ ⏳ 대기    │ ⏳ 대기    │ ⏳ 대기
 1000    │ 💳 주문중  │ ⏳ 대기    │ ⏳ 대기    │ ⏳ 대기    │ ⏳ 대기
 1500    │ ✅ 완료    │ 🔒 락획득  │ ⏳ 대기    │ ⏳ 대기    │ ⏳ 대기
 2000    │            │ 💳 주문중  │ ⏳ 대기    │ ⏳ 대기    │ ⏳ 대기
 2500    │            │ 💳 주문중  │ ⏳ 대기    │ ⏳ 대기    │ ⏳ 대기
 3000    │            │ ✅ 완료    │ 🔒 락획득  │ ⏳ 대기    │ ⏳ 대기
 3500    │            │            │ 💳 주문중  │ ⏳ 대기    │ ⏳ 대기
 4000    │            │            │ 💳 주문중  │ ⏳ 대기    │ ⏳ 대기
 4500    │            │            │ ✅ 완료    │ 🔒 락획득  │ ⏳ 대기
 5000    │            │            │            │ 💳 주문중  │ ⏳ 대기
 5500    │            │            │            │ 💳 주문중  │ ⏳ 대기
 6000    │            │            │            │ ✅ 완료    │ 🔒 락획득
 6500    │            │            │            │            │ 💳 주문중
 7000    │            │            │            │            │ 💳 주문중
 7500    │            │            │            │            │ ✅ 완료
```

**관찰 포인트:**
- 한 번에 하나씩만 실행 (순차 처리)
- 각 스레드는 약 1.5초 소요
- 전체 완료: 약 7.5초
- 동시에 실행됐다면? → 1.5초 (하지만 충돌!)

---

## 5. 락 키 설계의 중요성

### 케이스 1: 전역 락 (order:global)

```
Thread-1 (User-1, Product-A) → 🔒 order:global
Thread-2 (User-2, Product-B) → ⏳ 대기 (왜? 같은 락!)
Thread-3 (User-3, Product-C) → ⏳ 대기 (왜? 같은 락!)

문제: 서로 관계없는 주문도 대기 → 병목!
```

### 케이스 2: 상품별 락 (order:product:{id})

```
Thread-1 (User-1, Product-A) → 🔒 order:product:A
Thread-2 (User-1, Product-A) → ⏳ 대기 (같은 상품)
Thread-3 (User-2, Product-B) → 🔒 order:product:B (병렬 처리 ✅)

문제: 동일 사용자가 같은 상품 2번 주문은 막음
      하지만 다른 상품 2번 주문은 못 막음!
```

### 케이스 3: 사용자별 락 (order:user:{id}) ✅

```
Thread-1 (User-1, Product-A) → 🔒 order:user:1
Thread-2 (User-1, Product-B) → ⏳ 대기 (같은 사용자)
Thread-3 (User-2, Product-A) → 🔒 order:user:2 (병렬 처리 ✅)

장점:
- 동일 사용자 중복 주문 완벽 차단
- 다른 사용자는 병렬 처리 가능
- 우리 비즈니스에 딱 맞음!
```

---

## 6. 실전 시뮬레이션

### 재고 100개, 10명이 동시 주문 (각 10개씩)

#### ❌ 분산락 없을 때:

```
초기 재고: 100개

Thread-1 │ 재고 확인: 100 ✅ → 주문 시작
Thread-2 │ 재고 확인: 100 ✅ → 주문 시작
Thread-3 │ 재고 확인: 100 ✅ → 주문 시작
...
Thread-10│ 재고 확인: 100 ✅ → 주문 시작

모두 동시에 실행 →

Thread-1 │ 재고 감소: 100 - 10 = 90
Thread-2 │ 재고 감소: 100 - 10 = 90 (엥? 같은 값!)
Thread-3 │ 재고 감소: 100 - 10 = 90 (엥??)
...

결과: 재고 10개 (엥????)
예상: 100 - (10×10) = 0개
실제: 90개 (9번의 감소가 사라짐!)
```

#### ✅ 분산락 있을 때:

```
초기 재고: 100개

Thread-1 │ 🔒 락 획득 → 재고: 100 - 10 = 90 → 🔓
Thread-2 │ 🔒 락 획득 → 재고: 90 - 10 = 80 → 🔓
Thread-3 │ 🔒 락 획득 → 재고: 80 - 10 = 70 → 🔓
Thread-4 │ 🔒 락 획득 → 재고: 70 - 10 = 60 → 🔓
Thread-5 │ 🔒 락 획득 → 재고: 60 - 10 = 50 → 🔓
Thread-6 │ 🔒 락 획득 → 재고: 50 - 10 = 40 → 🔓
Thread-7 │ 🔒 락 획득 → 재고: 40 - 10 = 30 → 🔓
Thread-8 │ 🔒 락 획득 → 재고: 30 - 10 = 20 → 🔓
Thread-9 │ 🔒 락 획득 → 재고: 20 - 10 = 10 → 🔓
Thread-10│ 🔒 락 획득 → 재고: 10 - 10 = 0 → 🔓

결과: 재고 0개 ✅
모든 계산이 순차적으로 정확하게 실행!
```

---

## 7. 핵심 개념 정리

### Race Condition (경쟁 상태)
```
여러 스레드가 동시에 같은 데이터를 읽고 쓰면
예상치 못한 결과 발생

예) 재고 100개인데 10명이 동시 주문
   → 재고 확인: 모두 100개로 보임
   → 모두 주문 성공
   → 재고: 90개 (10개만 감소)
   → 나머지 90개는 허공으로...
```

### Critical Section (임계 영역)
```
동시에 실행되면 안 되는 코드 구간

우리 프로젝트:
┌────────────────────┐
│ 재고 확인          │ ← 임계 영역 시작
│ 재고 감소          │
│ 주문 생성          │
│ DB 저장            │ ← 임계 영역 끝
└────────────────────┘

→ 이 구간은 한 번에 하나씩만!
```

### Mutual Exclusion (상호 배제)
```
한 번에 하나의 스레드만 실행

분산락 = 상호 배제를 보장하는 도구
```

---

## 8. 동시성 제어 방법 비교

### 1. Java synchronized (JVM 레벨)
```java
synchronized void createOrder() {
    // 한 번에 하나씩
}

✅ 장점: 간단
❌ 단점: 같은 JVM 내에서만 동작
        여러 서버 있으면 소용없음!
```

### 2. DB 비관적 락 (DB 레벨)
```sql
SELECT * FROM product_options
WHERE id = 1
FOR UPDATE;  -- 이 행을 잠금

✅ 장점: DB가 보장
❌ 단점: DB 부하, 행 단위만 가능
        사용자 단위 제어 어려움
```

### 3. Redis 분산락 (애플리케이션 레벨) ✅
```java
RLock lock = redis.getLock("order:user:1");
lock.tryLock();

✅ 장점: 여러 서버 공유 가능
        메모리 기반으로 빠름
        유연한 키 설계
        TTL로 데드락 방지
❌ 단점: Redis 필요, 설정 복잡
```

---

## 9. 실습 체크리스트

완전히 이해했는지 확인:

- [ ] 동시성 문제가 뭔지 설명할 수 있다
- [ ] Race Condition이 왜 발생하는지 안다
- [ ] 분산락이 어떻게 동작하는지 설명할 수 있다
- [ ] Lua 스크립트가 왜 필요한지 안다
- [ ] 락 키 설계의 중요성을 안다
- [ ] tryLock 파라미터의 의미를 안다
- [ ] Pub/Sub 대기 방식을 이해한다
- [ ] Master-Replica 역할 분담을 안다
- [ ] TTL이 왜 필요한지 안다 (데드락 방지)
- [ ] 우리 프로젝트에 왜 사용자별 락인지 설명할 수 있다

모두 체크했다면 동시성 마스터! 🎉

---

## 10. 다음 단계

### 추가 학습 주제:
1. **낙관적 락 (Optimistic Lock)**
   - 버전 체크로 충돌 감지
   - 충돌 적은 경우 효율적

2. **분산 트랜잭션 (2PC, Saga)**
   - 여러 DB 간 일관성 보장
   - 마이크로서비스 환경

3. **이벤트 기반 아키텍처**
   - 비동기 처리로 동시성 회피
   - 메시지 큐 활용

### 실습 과제:
1. DistributedLockIntegrationTest 실행해보기
2. Redis CLI로 락 키 직접 확인
3. MONITOR로 명령어 흐름 관찰
4. 락 없이 테스트해서 Race Condition 재현

---

**핵심 한 줄:**
```
분산락 = 여러 서버가 공유하는 화장실 자물쇠
한 번에 하나씩만 들어가서 안전하게 사용!
```

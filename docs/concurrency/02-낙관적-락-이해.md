# 02. 낙관적 락으로 해결하기
---


**핵심 아이디어:**
- 여러 명이 같은 구글 문서를 편집
- 각자 편집 → 저장할 때 다른 사람이 먼저 수정했는지 확인
- 충돌 발생 → "새로고침 후 다시 시도하세요" 메시지

---
### 1단계: 버전 번호 추가

**파일:** `Coupon.java`

```java
@Entity
@Table(name = "coupons")
public class Coupon {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String code;
    private int totalQuantity;
    private int issuedQuantity;

    @Version
    private Long version;

    public void increaseIssuedQuantity() {
        this.issuedQuantity++;
    }
}
```

**version 컬럼:**
- 데이터가 수정될 때마다 자동으로 1씩 증가
- JPA가 자동 관리

---

### 2단계: UPDATE 쿼리에 version 조건 추가
```sql
UPDATE coupons
SET issued_quantity = 100
WHERE id = 1;
```

**낙관적 락 UPDATE:**
```sql
UPDATE coupons
SET issued_quantity = 100, version = 11
WHERE id = 1 AND version = 10;  -- ⭐ version 조건 추가!
```

---

### 3단계: 충돌 시 예외 발생

**실행 과정:**

```
[시간 0초]
사용자 A: SELECT * FROM coupons WHERE id = 1;
         → id=1, issued_quantity=99, version=10

사용자 B: SELECT * FROM coupons WHERE id = 1;
         → id=1, issued_quantity=99, version=10

[시간 1초]
사용자 A: UPDATE coupons
         SET issued_quantity = 100, version = 11
         WHERE id = 1 AND version = 10;
         → ✅ 성공! (1 row updated)

[시간 2초]
사용자 B: UPDATE coupons
         SET issued_quantity = 100, version = 11
         WHERE id = 1 AND version = 10;
         → ❌ 실패! (0 rows updated)
         → version이 이미 11로 바뀌어서 조건 불일치!
         → OptimisticLockException 발생!
```

---

**파일:** `IssueCouponUseCase.java`

```java
@Service
@Transactional
public class IssueCouponUseCase {
    private static final int MAX_RETRIES = 100;

    public UserCoupon execute(IssueCouponCommand command) {
        int retryCount = 0;

        while (retryCount < MAX_RETRIES) {
            try {
                // 1️⃣ 쿠폰 조회
                Coupon coupon = couponRepository.findById(command.getCouponId())
                    .orElseThrow(() -> new IllegalArgumentException("존재하지 않는 쿠폰"));

                // 2️⃣ 수량 검증
                if (coupon.getIssuedQuantity() >= coupon.getTotalQuantity()) {
                    throw new IllegalStateException("쿠폰이 모두 소진되었습니다");
                }

                // 3️⃣ 발급 수량 증가
                coupon.increaseIssuedQuantity();

                // 4️⃣ 저장 시도 (낙관적 락 검증!)
                couponRepository.save(coupon);
                // → UPDATE ... WHERE id = ? AND version = ?
                // → version 불일치 시 OptimisticLockException 발생!

                // 5️⃣ UserCoupon 생성
                UserCoupon userCoupon = new UserCoupon();
                userCoupon.setUserId(command.getUserId());
                userCoupon.setCouponId(coupon.getId());
                userCoupon.setStatus(UserCouponStatus.AVAILABLE);
                userCoupon.setIssuedAt(LocalDateTime.now());

                return userCouponRepository.save(userCoupon);

            } catch (OptimisticLockException e) {
                // 6️⃣ 충돌 발생 → 재시도!
                retryCount++;

                if (retryCount >= MAX_RETRIES) {
                    throw new IllegalStateException(
                        "쿠폰 발급 실패: 동시 요청이 너무 많습니다"
                    );
                }

                try {
                    // 7️⃣ 점진적 백오프 (2ms, 4ms, 6ms...)
                    Thread.sleep(retryCount * 2L);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new IllegalStateException("쿠폰 발급 중단됨");
                }
            }
        }

        throw new IllegalStateException("쿠폰 발급 실패");
    }
}
```

---

## 코드 상세 분석

### 재시도 로직

```java
while (retryCount < MAX_RETRIES) {
    try {
        // 쿠폰 발급 시도
    } catch (OptimisticLockException e) {
        retryCount++;
        Thread.sleep(retryCount * 2L);
    }
}
```

**왜 재시도?**
- 충돌은 "일시적인 문제"
- 다시 시도하면 성공할 가능성 높음

**MAX_RETRIES = 100인 이유:**
- 동시 요청이 많을수록 충돌 증가
- 100번 재시도 → 대부분의 경우 성공
- 실제 테스트: 100명 동시 요청 시 모두 성공 확인

---

### 점진적 백오프 (Exponential Backoff)

```java
Thread.sleep(retryCount * 2L);
```

| 재시도 횟수 | 대기 시간 |
|------------|-----------|
| 1회 | 2ms |
| 2회 | 4ms |
| 3회 | 6ms |
| 10회 | 20ms |
| 50회 | 100ms |
| 100회 | 200ms |

**왜 점진적으로 증가?**
- 모든 사용자가 동시에 재시도 → 또 충돌
- 시간차를 두고 재시도 → 충돌 감소

**왜 2ms?**
- 너무 짧으면: 여전히 충돌
- 너무 길면: 사용자 대기 시간 증가
- 2ms = 적절한 균형점

---

## 재고 차감도 동일한 방식

**파일:** `ProductOption.java`

```java
@Entity
@Table(name = "product_options")
public class ProductOption {
    @Id
    private Long id;

    private int stock;

    @Version 
    private Long version;

    public void decreaseStock(int quantity) {
        if (this.stock < quantity) {
            throw new IllegalArgumentException("재고가 부족합니다");
        }
        this.stock -= quantity;
    }

    public void increaseStock(int quantity) {
        this.stock += quantity;
    }
}
```

**DecreaseStockUseCase에서 사용:**

**파일:** `DecreaseStockUseCase.java`

```java
@Service
@Transactional
public class DecreaseStockUseCase {
    private static final int MAX_RETRIES = 50;

    public void execute(DecreaseStockCommand command) {
        int retryCount = 0;

        while (retryCount < MAX_RETRIES) {
            try {
                ProductOption option = productOptionRepository
                    .findById(command.getProductOptionId())
                    .orElseThrow();

                option.decreaseStock(command.getQuantity());
                productOptionRepository.save(option);

                return;

            } catch (OptimisticLockException e) {
                retryCount++;
                if (retryCount >= MAX_RETRIES) {
                    throw new IllegalStateException("재고 차감 실패");
                }

                try {
                    Thread.sleep(retryCount * 2L);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new IllegalStateException("재고 차감 중단");
                }
            }
        }
    }
}
```

**쿠폰과 동일한 패턴:**
1. @Version 필드
2. while 재시도 루프
3. OptimisticLockException 캐치
4. 점진적 백오프

---

## 테스트로 검증하기

### 쿠폰 동시성 테스트

**파일:** `CouponConcurrencyTest.java`

```java
@Test
@DisplayName("동시성 테스트 1: 사용자 100명, 쿠폰 100개")
void issue_coupon_concurrency_100_users_100_coupons() throws InterruptedException {
    // Given: 쿠폰 100개
    Coupon coupon = createCoupon("CONCURRENT100", 10000, 100, 0);

    int threadCount = 100;
    CountDownLatch latch = new CountDownLatch(threadCount);

    // When: 100명이 동시에 발급 요청
    for (int i = 0; i < threadCount; i++) {
        Long userId = (long) (i + 1);
        executorService.submit(() -> {
            try {
                issueCouponUseCase.execute(new IssueCouponCommand(userId, coupon.getId()));
            } finally {
                latch.countDown();
            }
        });
    }

    latch.await(60, TimeUnit.SECONDS);

    // Then: 정확히 100명만 발급 성공
    Coupon updated = couponRepository.findById(coupon.getId()).orElseThrow();
    assertThat(updated.getIssuedQuantity()).isEqualTo(100);
}
```

**실행 결과:** ✅ 통과
- 100명 동시 요청 → 100명 발급
- 낙관적 락으로 정확한 수량 제어

---

### 재고 동시성 테스트

**파일:** `StockConcurrencyTest.java`

```java
@Test
@DisplayName("재고 100개, 사용자 100명 동시 차감")
void decrease_stock_concurrency_100_users() throws InterruptedException {
    // Given: 재고 100개
    ProductOption option = createProductOption(1L, "RED", "L", 100);

    int threadCount = 100;
    CountDownLatch latch = new CountDownLatch(threadCount);

    // When: 100명이 동시에 1개씩 차감
    for (int i = 0; i < threadCount; i++) {
        executorService.submit(() -> {
            try {
                decreaseStockUseCase.execute(
                    new DecreaseStockCommand(option.getId(), 1)
                );
            } catch (Exception e) {
                // 실패는 무시 (재고 부족 등)
            } finally {
                latch.countDown();
            }
        });
    }

    latch.await(60, TimeUnit.SECONDS);

    // Then: 재고 정확히 0개
    ProductOption updated = productOptionRepository.findById(option.getId()).orElseThrow();
    assertThat(updated.getStock()).isEqualTo(0);
}
```

**실행 결과:** ✅ 통과
- 100명 동시 차감 → 재고 0개 (정확함)
- 마이너스 재고 발생 안 함

---

## 포인트 사용도 동일한 방식

**파일:** `Point.java`

```java
@Entity
@Table(name = "points")
public class Point {
    @Id
    private Long id;

    private Long userId;
    private Integer balance;

    @Version
    private Long version;

    public void use(int amount) {
        if (this.balance < amount) {
            throw new IllegalArgumentException("포인트가 부족합니다");
        }
        this.balance -= amount;
    }

    public void earn(int amount) {
        this.balance += amount;
    }
}
```

**UsePointUseCase에서 사용:**

**파일:** `UsePointUseCase.java`

```java
@Component
@Transactional
public class UsePointUseCase {
    private static final int MAX_RETRIES = 30;

    public void execute(UsePointCommand command) {
        int retryCount = 0;

        while (retryCount < MAX_RETRIES) {
            try {
                Point point = pointRepository
                    .findByUserId(command.getUserId())
                    .orElseThrow();

                point.use(command.getAmount());
                pointRepository.saveAndFlush(point);

                return;

            } catch (OptimisticLockingFailureException e) {
                retryCount++;
                if (retryCount >= MAX_RETRIES) {
                    throw new IllegalStateException("포인트 사용 실패");
                }

                try {
                    Thread.sleep(retryCount * 5L);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new IllegalStateException("포인트 사용 중단");
                }
            }
        }
    }
}
```

**쿠폰, 재고, 포인트 모두 동일한 패턴:**
1. @Version 필드
2. while 재시도 루프
3. OptimisticLockingFailureException 캐치
4. 점진적 백오프

---

## 추가 안전장치: UNIQUE 제약조건

**문제:** 같은 사용자가 같은 쿠폰을 여러 번 발급받으면?

**해결:** DB 레벨 중복 방지

**파일:** `UserCoupon.java`

```java
@Entity
@Table(name = "user_coupons",
    uniqueConstraints = {
        @UniqueConstraint(
            name = "uk_user_coupon",
            columnNames = {"user_id", "coupon_id"}
        )
    })
public class UserCoupon {
    // ...
}
```

**동작:**
```sql
-- 첫 번째 발급
INSERT INTO user_coupons (user_id, coupon_id) VALUES (1, 100);
-- ✅ 성공

-- 중복 발급 시도
INSERT INTO user_coupons (user_id, coupon_id) VALUES (1, 100);
-- ❌ 실패: Duplicate entry '1-100' for key 'uk_user_coupon'
```

**장점:**
- 애플리케이션 로직 실수가 있어도 DB가 막아줌
- Race Condition 완벽 방지

---

## 정리

### 현재 적용된 동시성 제어

| 대상 | 방법 | 파일 |
|------|------|------|
| **Coupon 발급** | @Version + 재시도(100회) | IssueCouponUseCase.java |
| **재고 차감** | @Version + 재시도(30회) | DecreaseStockUseCase.java |
| **포인트 사용** | @Version + 재시도(30회) | UsePointUseCase.java |
| **중복 발급 방지** | UNIQUE 제약조건 | UserCoupon.java |

### 핵심 개념

1. **@Version**: JPA가 자동으로 충돌 감지
2. **재시도**: 충돌 시 다시 시도
3. **점진적 백오프**: 대기 시간 점진적 증가
4. **UNIQUE 제약조건**: DB 레벨 중복 방지

### 테스트 결과

- ✅ 쿠폰 동시성 테스트 3개 통과
- ✅ 재고 동시성 테스트 4개 통과
- ✅ 포인트 동시성 테스트 4개 통과
- ✅ 정확한 수량 제어 확인

---
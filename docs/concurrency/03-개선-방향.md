# 03. 향후 개선 방향
---

## 현재 구현의 한계 -> STEP9,10 목표

### 1. UseCase가 너무 비대함

**문제:**
- `CreateOrderUseCase`가 100줄 이상
- 재고 차감, 쿠폰 처리, 주문 생성을 모두 담당

**파일:** `CreateOrderUseCase.java`

```java
@Service
@Transactional
public class CreateOrderUseCase {
    public Order execute(CreateOrderCommand command) {
        // 1. 재고 차감 로직 (20줄)
        for (OrderItem item : command.getOrderItems()) {
            ProductOption option = productOptionRepository.findById(...);
            option.decreaseStock(item.getQuantity());
            productOptionRepository.save(option);
            // ...
        }

        // 2. 쿠폰 처리 로직 (15줄)
        if (command.getUserCouponId() != null) {
            UserCoupon userCoupon = userCouponRepository.findById(...);
            userCoupon.use();
            // ...
        }

        // 3. 주문 생성 로직 (20줄)
        Order order = new Order();
        order.setUserId(command.getUserId());
        // ...

        // 4. 주문 항목 생성 로직 (15줄)
        for (OrderItem item : command.getOrderItems()) {
            item.setOrderId(order.getId());
            orderItemRepository.save(item);
        }

        return order;
    }
}
```

**왜 문제?**
- 코드가 길고 복잡해서 이해하기 어려움
- 테스트하기 어려움 (너무 많은 책임)
- 재사용 불가능 (다른 UseCase에서 재고 차감만 하고 싶어도 못 함)

---

## 개선 방향 1: Service 계층 분리

### Before (현재)

```
Controller → UseCase (모든 로직) → Repository
```

**문제점:**
- UseCase에 비즈니스 로직이 집중
- 재사용 불가능

---

### After (개선안)

```
Controller → UseCase (흐름 제어) → Service (비즈니스 로직) → Repository
```

**예시:**

```java
// StockService.java (신규 생성)
@Service
public class StockService {
    private final ProductOptionRepository productOptionRepository;
    private final StockHistoryRepository stockHistoryRepository;

    @Transactional
    public void decreaseStocks(List<OrderItem> orderItems) {
        for (OrderItem item : orderItems) {
            ProductOption option = productOptionRepository
                .findById(item.getProductOptionId())
                .orElseThrow(() -> new IllegalArgumentException("존재하지 않는 옵션"));

            option.decreaseStock(item.getQuantity());
            productOptionRepository.save(option);

            // 재고 이력 기록
            StockHistory history = new StockHistory();
            history.setProductOptionId(option.getId());
            history.setChangeQty(-item.getQuantity());
            history.setReason(StockChangeReason.ORDER);
            stockHistoryRepository.save(history);
        }
    }

    @Transactional
    public void increaseStocks(List<OrderItem> orderItems) {
        // 주문 취소 시 재고 복구
        for (OrderItem item : orderItems) {
            ProductOption option = productOptionRepository.findById(item.getProductOptionId()).orElseThrow();
            option.increaseStock(item.getQuantity());
            productOptionRepository.save(option);

            StockHistory history = new StockHistory();
            history.setProductOptionId(option.getId());
            history.setChangeQty(item.getQuantity());
            history.setReason(StockChangeReason.CANCEL);
            stockHistoryRepository.save(history);
        }
    }
}
```

```java
// CouponService.java (신규 생성)
@Service
public class CouponService {
    private final UserCouponRepository userCouponRepository;

    @Transactional
    public int applyCoupon(Long userCouponId) {
        if (userCouponId == null) {
            return 0;
        }

        UserCoupon userCoupon = userCouponRepository.findById(userCouponId)
            .orElseThrow(() -> new IllegalArgumentException("존재하지 않는 쿠폰"));

        if (userCoupon.getStatus() != UserCouponStatus.AVAILABLE) {
            throw new IllegalStateException("사용 불가능한 쿠폰");
        }

        userCoupon.use();
        userCouponRepository.save(userCoupon);

        Coupon coupon = couponRepository.findById(userCoupon.getCouponId()).orElseThrow();
        return coupon.getDiscountAmount();
    }

    @Transactional
    public void restoreCoupon(Long userCouponId) {
        // 주문 취소 시 쿠폰 복구
        if (userCouponId == null) return;

        UserCoupon userCoupon = userCouponRepository.findById(userCouponId).orElseThrow();
        userCoupon.restore();
        userCouponRepository.save(userCoupon);
    }
}
```

```java
// CreateOrderUseCase.java (개선 후)
@Service
@Transactional
public class CreateOrderUseCase {
    private final StockService stockService;       
    private final CouponService couponService;      
    private final OrderRepository orderRepository;

    public Order execute(CreateOrderCommand command) {
        // 1. 재고 차감 (위임)
        stockService.decreaseStocks(command.getOrderItems());

        // 2. 쿠폰 처리 (위임)
        int discountAmount = couponService.applyCoupon(command.getUserCouponId());

        // 3. 주문 생성
        int totalAmount = calculateTotalAmount(command.getOrderItems());
        Order order = new Order();
        order.setUserId(command.getUserId());
        order.setTotalAmount(totalAmount - discountAmount);
        order.setDiscountAmount(discountAmount);
        order.setUserCouponId(command.getUserCouponId());
        order.setStatus(OrderStatus.CREATED);

        return orderRepository.save(order);
    }

    private int calculateTotalAmount(List<OrderItem> items) {
        return items.stream()
            .mapToInt(item -> item.getPrice() * item.getQuantity())
            .sum();
    }
}
```

**장점:**
1. **UseCase 간소화**: 100줄 → 30줄
2. **재사용성**: `StockService`를 다른 UseCase에서도 사용 가능
3. **테스트 용이**: Service 단위로 테스트 가능
4. **책임 분리**: UseCase는 "흐름 제어", Service는 "비즈니스 로직"

**우선순위:** 
- 코드 가독성과 유지보수성에 직접 영향

---

## 개선 방향 2: 포인트 시스템 추가

### 현재 상황
- 주문 시 포인트 적립/사용 기능 없음
- 실제 이커머스는 포인트가 필수

### 추가할 엔티티

```java
// Point.java
@Entity
@Table(name = "points")
public class Point {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private Long userId;

    @Column(nullable = false)
    private int balance;  // 현재 포인트

    @Version 
    private Long version;

    public void earn(int amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("적립 금액은 양수여야 합니다");
        }
        this.balance += amount;
    }

    public void use(int amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("사용 금액은 양수여야 합니다");
        }
        if (this.balance < amount) {
            throw new IllegalStateException("포인트가 부족합니다");
        }
        this.balance -= amount;
    }
}
```

```java
// PointHistory.java
@Entity
@Table(name = "point_histories",
    indexes = {
        @Index(name = "idx_user_created", columnList = "user_id, created_at")
    })
public class PointHistory {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private Long userId;

    @Column(nullable = false)
    private int amount;  // + 적립, - 사용

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PointChangeReason reason;

    @Column(nullable = false)
    private LocalDateTime createdAt;
}

enum PointChangeReason {
    ORDER_EARN,    // 주문 적립
    ORDER_USE,     // 주문 사용
    CANCEL_REFUND  // 취소 환불
}
```

### PointService 구현

```java
@Service
public class PointService {
    private final PointRepository pointRepository;
    private final PointHistoryRepository pointHistoryRepository;

    private static final int MAX_RETRIES = 50;

    @Transactional
    public void usePoints(Long userId, int amount) {
        int retryCount = 0;

        while (retryCount < MAX_RETRIES) {
            try {
                Point point = pointRepository.findByUserId(userId)
                    .orElseThrow(() -> new IllegalArgumentException("존재하지 않는 사용자"));

                point.use(amount);  // 포인트 차감
                pointRepository.save(point);  //

                // 이력 기록
                PointHistory history = new PointHistory();
                history.setUserId(userId);
                history.setAmount(-amount);
                history.setReason(PointChangeReason.ORDER_USE);
                history.setCreatedAt(LocalDateTime.now());
                pointHistoryRepository.save(history);

                return;

            } catch (OptimisticLockException e) {
                retryCount++;
                if (retryCount >= MAX_RETRIES) {
                    throw new IllegalStateException("포인트 사용 실패");
                }

                try {
                    Thread.sleep(retryCount * 2L);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    throw new IllegalStateException("포인트 사용 중단");
                }
            }
        }
    }

    @Transactional
    public void earnPoints(Long userId, int amount, PointChangeReason reason) {
        // 적립은 충돌 가능성 낮음 (재시도 불필요)
        Point point = pointRepository.findByUserId(userId)
            .orElseGet(() -> {
                Point newPoint = new Point();
                newPoint.setUserId(userId);
                newPoint.setBalance(0);
                return pointRepository.save(newPoint);
            });

        point.earn(amount);
        pointRepository.save(point);

        PointHistory history = new PointHistory();
        history.setUserId(userId);
        history.setAmount(amount);
        history.setReason(reason);
        history.setCreatedAt(LocalDateTime.now());
        pointHistoryRepository.save(history);
    }
}
```

### CreateOrderUseCase에 통합

```java
@Service
@Transactional
public class CreateOrderUseCase {
    private final StockService stockService;
    private final CouponService couponService;
    private final PointService pointService;  // ⭐ 추가
    private final OrderRepository orderRepository;

    public Order execute(CreateOrderCommand command) {
        // 1. 재고 차감
        stockService.decreaseStocks(command.getOrderItems());

        // 2. 쿠폰 처리
        int discountAmount = couponService.applyCoupon(command.getUserCouponId());

        // 3. 포인트 사용 (⭐ 신규)
        if (command.getPointsToUse() > 0) {
            pointService.usePoints(command.getUserId(), command.getPointsToUse());
        }

        // 4. 주문 생성
        int totalAmount = calculateTotalAmount(command.getOrderItems());
        int finalAmount = totalAmount - discountAmount - command.getPointsToUse();

        Order order = new Order();
        order.setUserId(command.getUserId());
        order.setTotalAmount(finalAmount);
        order.setDiscountAmount(discountAmount);
        order.setUserCouponId(command.getUserCouponId());
        order.setStatus(OrderStatus.CREATED);
        Order savedOrder = orderRepository.save(order);

        // 5. 포인트 적립 (결제 금액의 1%) (⭐ 신규)
        int earnedPoints = (int) (finalAmount * 0.01);
        pointService.earnPoints(command.getUserId(), earnedPoints, PointChangeReason.ORDER_EARN);

        return savedOrder;
    }
}
```

**동시성 이슈:**
- 포인트도 쿠폰/재고와 동일한 동시성 문제 발생
- 해결: `@Version` 낙관적 락 + 재시도

**우선순위:** ⭐⭐ (높음)
- 기능적으로 중요
- 동시성 패턴을 반복 학습할 수 있음

---

## 개선 방향 3: 간단한 Payment 엔티티 ⭐

### 현재 상황
- 주문 생성 후 바로 `OrderStatus.CREATED`
- 실제 결제 처리 없음

### Option A: 간단한 Payment 엔티티 (추천)

```java
@Entity
@Table(name = "payments")
public class Payment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private Long orderId;

    @Column(nullable = false)
    private int amount;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PaymentMethod method;  // CARD, ACCOUNT, POINT

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private PaymentStatus status;  // PENDING, COMPLETED, FAILED

    private LocalDateTime paidAt;
}

enum PaymentMethod {
    CARD,     // 카드
    ACCOUNT,  // 계좌이체
    POINT     // 포인트 전액
}

enum PaymentStatus {
    PENDING,   // 결제 대기
    COMPLETED, // 결제 완료
    FAILED     // 결제 실패
}
```

### CreateOrderUseCase 수정

```java
public Order execute(CreateOrderCommand command) {
    // 1~4. 재고, 쿠폰, 포인트, 주문 생성 (동일)
    Order order = ...;

    // 5. 결제 생성 (⭐ 신규)
    Payment payment = new Payment();
    payment.setOrderId(order.getId());
    payment.setAmount(order.getTotalAmount());
    payment.setMethod(command.getPaymentMethod());
    payment.setStatus(PaymentStatus.PENDING);  // 일단 대기
    paymentRepository.save(payment);

    return order;
}
```

### 별도 UseCase: ProcessPaymentUseCase

```java
@Service
@Transactional
public class ProcessPaymentUseCase {
    public void execute(ProcessPaymentCommand command) {
        Payment payment = paymentRepository.findById(command.getPaymentId()).orElseThrow();

        // 실제로는 PG사 API 호출
        // 여기서는 단순화하여 즉시 성공 처리
        payment.setStatus(PaymentStatus.COMPLETED);
        payment.setPaidAt(LocalDateTime.now());
        paymentRepository.save(payment);

        // 주문 상태 변경
        Order order = orderRepository.findById(payment.getOrderId()).orElseThrow();
        order.setStatus(OrderStatus.PAID);
        orderRepository.save(order);
    }
}
```

**우선순위:** ⭐ (중간)
- 기본적인 Payment 엔티티만 추가
- PG 연동은 제외 (너무 복잡함)

---

## 개선 방향 4: 대용량 트래픽 대비

### 현재 아키텍처의 한계

**시나리오: 대규모 이벤트**
- 동시 접속 10,000명
- 초당 요청 1,000건 (TPS)
- 쿠폰 100개 선착순

**문제점:**

1. **낙관적 락 재시도 폭주**
   - 10,000명 × 100번 재시도 = 1,000,000건 쿼리
   - DB 부하 폭증

2. **Connection Pool 고갈**
   - HikariCP 기본: 10개
   - 동시 요청 1,000건 → 대기 시간 증가

3. **단일 장애점 (SPOF)**
   - DB 다운 → 전체 서비스 중단

---

### 해결 방안 1: Redis 분산 락

```java
@Service
public class IssueCouponUseCase {
    private final RedissonClient redisson;

    public UserCoupon execute(IssueCouponCommand command) {
        String lockKey = "coupon:lock:" + command.getCouponId();
        RLock lock = redisson.getLock(lockKey);

        try {
            // 5초 대기, 10초 후 자동 해제
            if (lock.tryLock(5, 10, TimeUnit.SECONDS)) {
                // 쿠폰 발급 로직 (재시도 불필요!)
                return issueCoupon(command);
            } else {
                throw new IllegalStateException("쿠폰 발급 실패");
            }
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}
```

**장점:**
- DB 부하 대폭 감소
- 재시도 불필요
- 여러 서버에서 동작 (분산 환경)

**단점:**
- Redis 의존성 추가
- 운영 복잡도 증가

---

### 해결 방안 2: 메시지 큐 (Kafka)

```java
// 비동기 처리
@Service
public class IssueCouponUseCase {
    private final KafkaTemplate<String, CouponIssueEvent> kafka;

    public void execute(IssueCouponCommand command) {
        CouponIssueEvent event = new CouponIssueEvent(
            command.getUserId(),
            command.getCouponId()
        );

        // 큐에 넣고 즉시 리턴
        kafka.send("coupon-issue-topic", event);

        // 사용자: "발급 대기 중" 메시지
    }
}

// Consumer가 순차 처리
@KafkaListener(topics = "coupon-issue-topic")
public void handleCouponIssue(CouponIssueEvent event) {
    // 하나씩 처리 → 동시성 문제 원천 차단
    couponService.issue(event.getUserId(), event.getCouponId());
}
```

**장점:**
- 동시성 문제 원천 차단
- 서버 부하 분산
- 실패 시 재처리 가능

**단점:**
- 즉시 응답 불가 (비동기)
- Kafka 운영 필요

---

### 해결 방안 3: Connection Pool 튜닝

```yaml
# application.yml
spring:
  datasource:
    hikari:
      maximum-pool-size: 50  # 10 → 50
      minimum-idle: 10
      connection-timeout: 30000
```

**주의:**
- Pool 크기 무작정 증가 X
- DB 성능에 맞춰 조정 필요

---

### 해결 방안 4: Read Replica

```java
// 조회는 Replica, 쓰기는 Master
@Transactional(readOnly = true)
public List<Product> getProductList() {
    return productRepository.findAll();  // Replica
}

@Transactional
public Order createOrder(CreateOrderCommand command) {
    return orderRepository.save(order);  // Master
}
```

**장점:**
- 조회 부하 분산
- Master DB 부담 감소

---

## 정리: 우선순위별 개선 계획

### 1순위
- **Service 계층 분리**
- StockService, CouponService 생성
- UseCase 간소화

### 2순위
- **포인트 시스템 추가**
- Point, PointHistory 엔티티
- PointService 생성
- 낙관적 락 적용

### 3순위
- **간단한 Payment 엔티티**
- Payment 테이블만 추가
- PG 연동은 제외

### 4순위 추후 목표
- **대용량 대비 방안 조사**
- Redis 분산 락 학습
- Kafka 메시지 큐 학습
- Connection Pool 튜닝
- Read Replica 구성

---

## 학습 로드맵

**현재 (STEP 09):**
- ✅ 동시성 문제 이해
- ✅ 낙관적 락 이해
- ✅ 재시도 메커니즘 이해

**다음 (STEP 10):**
- Service 계층 분리 실습
- 포인트 시스템 구현
- 테스트 강화

**향후:**
- Redis 분산 락 실습
- Kafka 메시지 큐 실습
- 대용량 아키텍처 설계

---
# 동시성 제어 분석 보고서

## 1. 개요

본 이커머스 시스템에서는 다음 두 가지 핵심 기능에 대한 동시성 제어가 필요합니다:

- **재고 차감**: 여러 사용자가 동시에 같은 상품을 주문할 때 재고가 음수가 되지 않도록 보장
- **선착순 쿠폰 발급**: 한정된 수량의 쿠폰을 발급할 때 발급 한도를 초과하지 않도록 보장

---

## 2. 선택한 동시성 제어 방식

### synchronized + ConcurrentHashMap 기반 ID별 Lock

**핵심 전략:**
- 각 리소스(ProductOption, Coupon) ID별로 별도의 Lock 객체를 관리
- ConcurrentHashMap을 사용하여 Lock 객체 저장
- computeIfAbsent()를 사용한 Thread-safe한 Lock 객체 생성
- synchronized 블록으로 임계 영역 보호

**구현 예시:**

```java
// StockService
private final Map<Long, Object> lockMap = new ConcurrentHashMap<>();

public void decreaseStock(Long productOptionId, int quantity, StockChangeReason reason) {
    Object lock = lockMap.computeIfAbsent(productOptionId, k -> new Object());
    
    synchronized (lock) {
        // 재고 조회 → 검증 → 차감 → 저장 (원자성 보장)
    }
}
```

---

## 3. 동작 원리

### Race Condition이 발생하는 시나리오

**동시성 제어가 없을 때:**

```
시간 | Thread A              | Thread B              | 재고
-----|----------------------|----------------------|-----
T1   | 재고 조회 (10개)      |                      | 10
T2   |                      | 재고 조회 (10개)      | 10
T3   | 재고 부족 체크 통과   |                      | 10
T4   |                      | 재고 부족 체크 통과   | 10
T5   | 재고 차감 (10 - 8)   |                      | 2
T6   |                      | 재고 차감 (10 - 8)   | 2 (!!)
```

→ **문제**: 재고 10개인데 16개가 판매됨 (재고 음수 또는 초과 판매)

**동시성 제어 적용 후:**

```
시간 | Thread A              | Thread B              | 재고
-----|----------------------|----------------------|-----
T1   | Lock 획득            |                      | 10
T2   | 재고 조회 (10개)      | Lock 대기 중         | 10
T3   | 재고 부족 체크 통과   | Lock 대기 중         | 10
T4   | 재고 차감 (10 - 8)   | Lock 대기 중         | 2
T5   | Lock 해제            | Lock 획득            | 2
T6   |                      | 재고 조회 (2개)      | 2
T7   |                      | 재고 부족 예외 발생  | 2
```

→ **해결**: 순차적으로 처리되어 재고 정합성 보장

---

## 4. 장점

### 1) 간단하고 직관적인 구현
- Java 기본 기능(synchronized)만 사용
- 추가 라이브러리나 프레임워크 불필요
- 코드 이해와 유지보수가 쉬움

### 2) Thread-safe 보장
- synchronized 키워드로 확실한 상호 배제 보장
- Visibility와 Atomicity 모두 보장 (Java Memory Model)

### 3) 세밀한 Lock Granularity
- ID별 Lock으로 병렬 처리 가능
- 서로 다른 상품의 재고 차감은 동시 실행 가능
- 전체 서비스 Lock 대비 성능 향상

### 4) 인메모리 환경에 최적
- DB Lock 불필요
- 네트워크 지연 없음
- 빠른 Lock 획득/해제

---

## 5. 단점

### 1) 메모리 사용 증가
- Lock 객체가 계속 누적됨 (lockMap에서 제거 안 함)
- 많은 상품/쿠폰이 있을 경우 메모리 부담 가능

### 2) 단일 서버 환경에서만 동작
- 분산 환경(멀티 서버)에서는 작동하지 않음
- Scale-out 불가

### 3) 성능 제한
- 같은 리소스에 대한 동시 요청은 직렬화됨
- 고부하 시 대기 시간 증가 가능

---

## 6. 대안 방식 비교

### 6.1 ReentrantLock

**설명:** java.util.concurrent.locks.ReentrantLock 사용

**장점:**
- tryLock() 지원 (타임아웃 설정 가능)
- 공정성(Fairness) 모드 선택 가능
- 조건 변수(Condition) 지원

**단점:**
- 명시적으로 lock(), unlock() 호출 필요 (코드 복잡도 증가)
- finally 블록에서 unlock() 보장 필수

**선택하지 않은 이유:**
- 현재 요구사항에 타임아웃이나 조건 변수가 불필요
- synchronized로 충분히 간결하고 안전한 구현 가능

---

### 6.2 Optimistic Lock (낙관적 락)

**설명:** 버전 번호(Version)를 사용하여 충돌 감지

**장점:**
- Lock을 걸지 않아 성능 우수
- 읽기 작업이 많을 때 유리

**단점:**
- 충돌 발생 시 재시도 로직 필요 (복잡도 증가)
- 높은 동시성 환경에서 재시도 횟수 증가
- Version 필드 추가 필요

**선택하지 않은 이유:**
- 선착순 쿠폰과 재고 차감은 쓰기 작업이 많음 (낙관적 락 비효율)
- 재시도 로직이 복잡하고, 고부하 시 성능 저하
- 인메모리 환경에서 synchronized가 더 단순하고 효율적

---

### 6.3 Pessimistic Lock (비관적 락)

**설명:** DB 수준에서 Lock 획득 (SELECT FOR UPDATE)

**장점:**
- DB 수준에서 동시성 보장
- 분산 환경에서도 동작 가능

**단점:**
- DB Lock으로 인한 성능 저하
- Deadlock 위험 증가
- 인메모리 환경에서는 불필요

**선택하지 않은 이유:**
- 인메모리 기반 시스템이므로 DB 불필요
- DB Lock은 네트워크 지연과 성능 오버헤드 발생
- 애플리케이션 레벨 Lock이 더 빠르고 적합

---

### 6.4 분산 Lock (Redis, Zookeeper)

**설명:** 외부 저장소를 사용한 분산 Lock

**장점:**
- 멀티 서버 환경에서 동작
- Scale-out 가능

**단점:**
- 외부 의존성 추가 (Redis, Zookeeper 필요)
- 네트워크 지연 발생
- 복잡도 증가

**선택하지 않은 이유:**
- 현재는 인메모리 기반 단일 서버
- 분산 환경이 아니므로 과도한 설계
- 추후 Scale-out 시 도입 고려 가능

---

## 7. 테스트 결과

### 재고 차감 동시성 테스트

#### 테스트 1: 재고 100개, 동시 요청 100개
- 결과: 성공 100건, 실패 0건
- 최종 재고: 0개
- 검증: ✅ 정확히 100개만 차감됨

#### 테스트 2: 재고 100개, 동시 요청 150개
- 결과: 성공 100건, 실패 50건
- 최종 재고: 0개
- 검증: ✅ 재고 한도 초과 방지 성공

#### 테스트 3: 재고 10개, 동시 요청 20개
- 결과: 재고가 절대 음수가 되지 않음
- 최종 재고: 0개
- 검증: ✅ Race Condition 완전 차단

### 쿠폰 발급 동시성 테스트

#### 테스트 1: 쿠폰 100개, 동시 요청 100개
- 결과: 성공 100건, 실패 0건
- 최종 발급 수량: 100개
- 검증: ✅ 정확히 100개만 발급됨

#### 테스트 2: 쿠폰 100개, 동시 요청 200개
- 결과: 성공 100건, 실패 100건
- 최종 발급 수량: 100개
- 검증: ✅ 발급 한도 초과 방지 성공

---

## 8. 결론

**synchronized + ConcurrentHashMap 기반 ID별 Lock**은 다음 이유로 현재 시스템에 최적입니다:

1. **인메모리 환경**: DB Lock이나 분산 Lock 불필요
2. **간결성**: Java 기본 기능만으로 안전한 동시성 제어 가능
3. **성능**: ID별 Lock으로 병렬성 유지
4. **정합성**: 재고와 쿠폰의 정확한 한도 보장

### 향후 개선 방향

1. **Lock 메모리 관리**: WeakHashMap 사용 또는 주기적 정리
2. **분산 환경 대응**: 멀티 서버 환경으로 Scale-out 시 Redis 분산 Lock 도입
3. **모니터링 강화**: Lock 대기 시간 측정, Deadlock 탐지
4. **성능 최적화**: Lock Striping, Read-Write Lock 적용

---

**작성일**: 2025-01-06  
**버전**: 1.0  
**작성자**: E-commerce Development Team
